#!/usr/bin/env -S python3 -B

import argparse
import io
import os
import sys
import threading
import yaml
from pathlib import Path
from sh import zsh, git, msmtp  # type: ignore
from tempfile import TemporaryDirectory
from typing import Any, Dict, List, Optional, Union


def replace_tilde(path: str) -> str:
    if path.startswith("~"):
        return str(Path.home()) + path[1:]
    return path


def warp_path(path: str) -> Optional[str]:
    warprc_path = os.path.join(Path.home(), ".warprc")
    if not os.path.exists(warprc_path):
        print("Cannot find .warprc")
        return None

    with open(warprc_path, "r") as warprc:
        for line in warprc:
            key, value = line.rstrip().split(":")
            if key != path:
                continue

            return replace_tilde(value)

    return None


def has_git(path: str) -> bool:
    return os.path.exists(os.path.join(path, ".git"))


def subdirs(path: str) -> List[str]:
    result = []
    for subdir in os.listdir(path):
        fullpath = os.path.join(path, subdir)
        if has_git(fullpath):
            result.append(subdir)
    return result


red = "\u001b[31m"
yellow = "\u001b[33m"
blue = "\u001b[34m"
normal = "\u001b[0m"


class Job(threading.Thread):
    def __init__(
        self, sem: threading.Semaphore, jobspec: Dict[str, Any], path: str
    ):
        super(Job, self).__init__()
        self.sem = sem
        self.path = path
        self.jobspec = jobspec
        self.buf = io.StringIO()
        self.failed = False
        self.clone_repo: Optional[TemporaryDirectory[str]] = None

        self.start()

    def run(self) -> None:
        self.sem.acquire()

        path_short = os.path.basename(self.path)
        print(path_short, file=self.buf)
        try:
            if self.requires():
                self.steps()
        except Exception as e:
            onfail = self.jobspec.get("on-fail", "print")

            if onfail == "print":
                print(f"Exception: {e}", file=self.buf)
            elif onfail == "email":
                email = f"""\
Subject: Job failed: {self.jobspec["name"]}

Log:
{self.buf.getvalue().rstrip()}

Exception:
{e}
"""
                msmtp("--", "patrick@stwcx.xyz", _in=email)

            self.failed = True

        self.sem.release()

    def requires(self) -> bool:
        for r in self.jobspec.get("requires", []):
            if isinstance(r, str):
                fn = r
                arg = None
            else:
                fn, arg = list(r.items())[0]

            fnn = "require_" + fn
            if fnn not in Job.__dict__:
                fnn = "cmd_" + fn
            if fnn not in Job.__dict__:
                raise Exception(f"Cannot find command handler for {fn}.")

            try:
                new_path = Job.__dict__[fnn](self, arg)
                if new_path:
                    self.path = new_path
            except:
                return False
        return True

    def steps(self) -> None:
        for c in self.jobspec["run"]:
            if isinstance(c, str):
                fn = c
                arg = None
            else:
                fn, arg = list(c.items())[0]

            fn = "cmd_" + fn

            if fn not in Job.__dict__:
                raise Exception(f"Cannot find command handler for {fn}.")

            new_path = Job.__dict__[fn](self, arg)
            if new_path:
                self.path = new_path

    def cmd_fetch(self, arg: Optional[str]) -> None:
        if not arg:
            arg = "origin"
        if arg == "all":
            arg = "--all"
        git.bake("-C", self.path).fetch(arg)

    def cmd_rebase(self, arg: Optional[str]) -> None:
        gitc = git.bake("-C", self.path)

        dirty = False
        if gitc.status("-suno"):
            dirty = True

        remotes = [x.rstrip() for x in gitc.remote()]
        remote = None
        if "upstream" in remotes:
            remote = "upstream"
        elif "origin" in remotes:
            remote = "origin"

        branch = gitc.branch("--show-current").rstrip()

        if not branch:
            print(f"    Branch: {red}NONE{normal}", file=self.buf)
        elif remote and not dirty and branch in ["main", "master", "develop"]:
            gitc.rebase("-q", f"{remote}/{branch}")
        elif not dirty:
            print(f"    Branch: {branch}", file=self.buf)
        else:
            print(f"    Branch: {branch} {red}(dirty){normal}", file=self.buf)

    def cmd_shell(self, arg: Optional[str]) -> None:
        if not arg:
            raise Exception("Missing shell argument")

        print(
            zsh(
                "-c", f"cd {self.path} && {arg}", _out=self.buf, _tty_out=False
            ).rstrip(),
            file=self.buf,
        )

    def cmd_cd(self, arg: Optional[str]) -> None:
        if not arg:
            raise Exception("Missing directory argument")

        self.path = os.path.normpath(os.path.join(self.path, arg))

    def cmd_clone(self, arg: Optional[str]) -> str:
        if self.clone_repo:
            raise Exception("Can only clone once.")

        if not arg:
            arg = "origin"

        self.clone_repo = TemporaryDirectory()

        url = None
        for l in git.bake("-C", self.path).remote("-v").splitlines():
            if l.startswith(arg) and "(fetch)" in l:
                url = l.split()[1]
        if not url:
            raise Exception(f"Cannot find remote: {arg}")

        git.clone("--reference", self.path, url, self.clone_repo.name)
        return self.clone_repo.name

    def cmd_write_file(self, arg: Optional[str]) -> None:
        if not arg:
            raise Exception("Missing arguments")

        args = arg.splitlines()
        file = args[0]
        text = "\n".join(args[1:])

        with open(os.path.join(self.path, file), "w") as fp:
            fp.write(text)

    def require_remote(self, arg: Optional[str]) -> None:
        if not arg:
            raise Exception("Missing remote argument")

        gitc = git.bake("-C", self.path)
        if arg not in gitc.remote("-v"):
            raise Exception("Remote not found")


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-s", "--jobspec", required=True, help="Job Spec to execute"
    )

    args = parser.parse_args()

    if not os.path.exists(args.jobspec):
        args.jobspec = replace_tilde(f"~/.config/obmc-jobber/{args.jobspec}")

    if os.path.isdir(args.jobspec):
        args.jobspec = sorted(
            [
                os.path.join(args.jobspec, f.name)
                for f in os.scandir(args.jobspec)
                if f.is_file() and os.path.splitext(f.name)[1] == ".yaml"
            ]
        )
    else:
        args.jobspec = [args.jobspec]

    failed = False
    for j in args.jobspec:
        if not run_jobspec(j):
            failed = True

    return 1 if failed else 0


def run_jobspec(jsfile: str) -> bool:
    with open(jsfile, "r") as jobspec:
        job = yaml.safe_load(jobspec)
    if "name" not in job:
        job["name"] = os.path.splitext(os.path.basename(jsfile))[0]

    where = job["where"]
    if isinstance(where, list):
        first = warp_path(where[0])
        if first:
            where = "/".join([first] + where[1:])
    if not os.path.exists(where):
        where = warp_path(where)
    if not os.path.exists(where):
        print("Cannot find job location:", where)
        return False

    directories = [where]
    if not has_git(where):
        directories = [os.path.join(where, x) for x in subdirs(where)]

    if "run" not in job:
        print("No job 'run' directive.")
        return False

    sem = threading.Semaphore(job.get("limit", 10))

    failed = False
    jobs: List[Job] = []
    for d in directories:
        jobs.append(Job(sem, job, d))

    for j in jobs:
        j.join()
        failed = failed | j.failed
        print(j.buf.getvalue().rstrip())

    return not failed


if __name__ == "__main__":
    sys.exit(main())
